{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Python Physics","text":"<p>Python Physics is an introduction to numerical methods in physics using Python. I am a Professor of Physics at Bard College and eventually this website will include notebooks from throughout our physics curriculum. At the moment the site only includes examples drawn from our 300-level Electricity and Magnetism course and focuses on:</p> <ul> <li>Scientific computing with NumPy, SciPy and Matplotlib</li> <li>Applications in Electricity and Magnetism</li> </ul> <p>I owe a big debt of gratitude to Patrick Walls, whose Mathematical Python provided the example for me to learn the Material theme from MKDocs and this convenient deployment on GitHub.</p> <pre><code>January 26 2024 10:41 PST\n</code></pre>"},{"location":"ElecMag/2DRelaxation/","title":"2D Relaxation","text":"<pre><code>import numpy as np\nimport matplotlib.pyplot as plt\nimport numpy.linalg as linalg\n</code></pre> <p>The techniques for doing relaxation that you've learned over the last two notebooks generalize nicely to two-dimensions (2D). Further generalization to higher dimensions then proceeds similarly. </p>"},{"location":"ElecMag/2DRelaxation/#physical-setup","title":"Physical Setup","text":"<p>For some time we will focus on numerically solving a single physical problem. In electrostatics the easiest way to realize this problem is with an idealized three-dimensional setup, however the symmetry along the \\(z\\)-axis will make it so that we really only need to solve a 2D problem. </p> <p>The setup is as follows: Three infinitely-long grounded metal plates, at \\(x=0\\), \\(x=1\\) and \\(y = 0\\), are connected at \\(y = 1\\) by a metal strip maintained at a  potential \\(V(x,y=1) = \\sin(\\pi x)\\) (a thin layer of insulation at each corner prevents them from shorting out). Find the potential inside the resulting rectangular pipe. The equation that dictates the potential is the 2D Laplace equation, to which we now turn.</p>"},{"location":"ElecMag/2DRelaxation/#the-laplace-equation-in-2d","title":"The Laplace Equation in 2D","text":"<p>The 2D Laplace equation is </p> \\[ \\nabla^2 V = \\frac{\\partial^2 V}{\\partial x^2}+\\frac{\\partial^2 V}{\\partial y^2} = 0. \\] <p>Just as in 1D, this equation can be discretized by returning to the definition of the partial derivatives \\(\\partial/\\partial x\\) and \\(\\partial/\\partial y\\). However, in this case it is useful to allow yourself to have different step sizes in the \\(x\\)- and in the \\(y\\)-directions. To this end, instead of using \\(h\\) to indicate a numerical step size, let \\(\\Delta x\\) represent a single step in the \\(x\\)-direction and similarly for \\(\\Delta y\\).  In the numerics below we will often give these step sizes the same value, e.g. \\(\\Delta x = \\Delta y =1\\), but by setting the calculation up this way, you are free not to. </p> <p>As before, it is also useful to setup a shorthand for the potential evaluated on a lattice point. In 2D a given lattice point will have \\(x\\) and \\(y\\) coordinates. Define these coordinates to be \\(x_i\\) and \\(y_j\\), where the subscript \\(i\\) means that \\(x_i\\) is \\(i\\) steps to the right of the origin, and with \\(i\\) and \\(j\\) both integers. In other words \\(x_i = i\\cdot \\Delta x\\). Similarly, \\(y_j = j \\cdot \\Delta y\\) is \\(j\\) steps above the origin. Finally, we define the potential \\(V\\) at the lattice point \\((x_i, y_j)\\) to be \\(V(x_i, y_j) \\equiv V_{i,j}\\). The comma in the subscript of \\(V_{i,j}\\) simply acts to separate the \\(i\\) and \\(j\\) values.</p> <p>Exercise (a): With the conventions just described, discretize \\(\\nabla^2V\\) and write out the discrete Laplace equation. [Ans:</p> \\[ \\frac{V_{i+1,j}-2V_{i,j}+V_{i-1,j}}{\\Delta x^2} + \\frac{V_{i,j+1}-2V_{i,j}+V_{i,j-1}}{\\Delta y^2} =0.] \\]"},{"location":"ElecMag/2DRelaxation/#constructing-lattices-in-2d","title":"Constructing lattices in 2d","text":"<p>The conventions described above go a long way to describing 2D lattices, but we still need a way to represent them in Python. Visualizing the lattice will be invaluable as well. </p> <p>Fortunately, the NumPy meshgrid function, already introduced in the notebook on plotting vector fields, does a lot of the work for us. The vector field notebook took a 'black box' approach to meshgrid, using it without worrying much about understanding it. Here we will begin to better understand how this function works. </p> <p>The meshrid function works in any number of dimensions, but we will focus on the 2D case. In this case meshgrid accepts two arrays as inputs, treats them as lattices in the \\(x\\) and \\(y\\) directions, and returns a 2D lattice of points in the \\(xy\\) plane. For example, if you supply the arrays [0,1,2] and [0,1,2] as inputs, then it returns two 3x3 arrays consisting of the \\(x\\) and \\(y\\) coordinates of the 9 points of the 2D lattice formed by the Cartesian product of the two input arrays. This is easier to see than to read:</p> <pre><code>x,y = np.meshgrid(np.linspace(0,2,3),np.linspace(0,2,3))\n\nfig, ax = plt.subplots() \nax.plot(x,y,\"ko\") \nplt.show()\n</code></pre> <p></p> <p>This example shows how well meshgrid and matplotlib fit together. And, once you've seen a picture of it, it is easier to parse out how Python does it. Printing out the two arrays yields:</p> <pre><code>x,y = np.meshgrid(np.linspace(0,2,3),np.linspace(0,2,3))\nprint(x)\nprint(y)\n</code></pre> <pre><code>[[0. 1. 2.]\n [0. 1. 2.]\n [0. 1. 2.]]\n[[0. 0. 0.]\n [1. 1. 1.]\n [2. 2. 2.]]\n</code></pre> <p>The first array stores the \\(x\\)-coordinates of each row of points in the rows of an array, and similarly for \\(y\\)-coordinates in the 2nd array. In fact, by looking at the 2nd array, we can see that the first row of the array corresponds to the point lowest on the diagram, the 2nd row to the middle points, and the 3rd to the uppermost points. </p> <p>Implicit in these arrays, then, is a way of moving through the points of the lattice that we will use in our code too. The elements of the arrays begin with the lower left point of the lattice, move along the bottom row, from left to right, shift up to the middle row, proceed left to right again, and finally do the same along the uppermost row. Expressing this in terms of the potential \\(V_{i,j}\\) of the last section, we begin with \\(V_{0,0}\\), go to \\(V_{0,1}\\) and \\(V_{0,2}\\), then go to \\(V_{1,0}\\), \\(V_{1,1}\\), and \\(V_{1,2}\\), and finally visit \\(V_{2,0}\\), \\(V_{2,1}\\), and \\(V_{2,2}\\).  You may find it helpful to have the mental image of an arrow zig-zagging from one row of lattice points to the next, as in the plot below:</p> <pre><code>x,y = np.meshgrid(np.linspace(0,2,3),np.linspace(0,2,3))\n\nfig, ax = plt.subplots() \nax.plot(x,y,\"ko\") \n\n#The annotate command allows you to add things (arrows, text, etc) on top of a plot\nax.annotate(\"\",\n            xy=(0, 0.9), xycoords='data',\n            xytext=(0, 0.1), textcoords='data',\n            arrowprops=dict(arrowstyle=\"-&gt;\", connectionstyle=\"arc,angleA=0,angleB=0,armA=460,armB=0,rad=30\"))\nax.annotate(\"\",\n            xy=(0, 1.9), xycoords='data',\n            xytext=(0, 1.1), textcoords='data',\n            arrowprops=dict(arrowstyle=\"-&gt;\", connectionstyle=\"arc,angleA=0,angleB=0,armA=460,armB=0,rad=30\"))\nax.annotate(\"\",\n            xy=(1.94, 1.94), xycoords='data',\n            xytext=(0, 1.94), textcoords='data',\n            arrowprops=dict(arrowstyle=\"-&gt;\", connectionstyle=\"arc3\"))\nplt.show()\n</code></pre> <p></p>"},{"location":"ElecMag/2DRelaxation/#boundary-values-in-2d","title":"Boundary Values in 2D","text":"<p>Before moving on to solving Laplace's equation in 2D, it is useful to think again about boundary values. As before we will focus on the simplest case, where boundary values are specified all the way around the boundary of the 2D region. These are called Dirichlet boundary conditions, and contrast with problems where you specify the derivative of the potential on one or more boundaries; the latter are called Neumann boundary conditions and will be taken up in a future notebook.</p> <p>The figure below depicts a 5x5 lattice. Highlighted in blue are the internal lattice points, where the potential \\(V_{i,j}\\) is completely unknown. In magenta, are boundary lattice points where the potential is given. In black, there is a set of corner lattice points, which you could consider 'boundary lattice points', but which won't come into any of the equations and, therefore, are easier to ignore. </p> <pre><code>x,y = np.meshgrid(np.linspace(0,4,5),np.linspace(0,4,5))\nxin, yin = np.meshgrid(np.linspace(1,3,3),np.linspace(1,3,3))\nxc, yc = np.meshgrid(np.linspace(0,4,2),np.linspace(0,4,2))\n\nfig, ax = plt.subplots() #Setup figure\n\nax.plot(x,y,\"-k\")\nax.plot(y,x,\"-k\")\nax.plot(x,y,\"mo\",xin,yin,\"bo\",xc,yc,\"ko\") #Make plot\n\n\nplt.show()\n</code></pre> <p></p> <p>These differences are useful to highlight, because, whether you use an iterative method or the linear algebra approach, in both cases you need to be aware that you are only trying to solve the potential at the blue points. At the other points the potential is either given or irrelevant. This determines how you define the loops in the iterative process, or the matrix you are trying to invert in the linear algebra case. </p> <p>In this notebook we will focus on the linear algebra approach.</p>"},{"location":"ElecMag/2DRelaxation/#the-structure-of-the-linear-algebra-problem","title":"The Structure of the Linear Algebra Problem","text":"<p>If you stare at the lattice just depicted, you will notice that each of the nine blue points is different. Some of the points have two magenta neighbors, but others only have one or none. For some, the magenta neighbor is above and for others it is to the right. These differences change the structure of the linear algebra problem. </p> <p>To illustrate this, I'll figure out the discrete Laplace equation for \\(V_{3,2}\\), that is for \\(i=3\\) and \\(j=2\\), in the case that \\(\\Delta x = \\Delta y\\). Beginning with </p> \\[ \\frac{V_{4,2}-2V_{3,2}+V_{2,2}}{\\Delta x^2} + \\frac{V_{3,3}-2V_{3,2}+V_{3,1}}{\\Delta y^2} =0,  \\] <p>I multiply through by \\(\\Delta x^2 = \\Delta y^2\\) and move the known \\(V_{4,2}\\) to the right to get</p> \\[ -4V_{3,2}+V_{2,2}+V_{3,3}+V_{3,1} = -V_{4,2}. \\] <p>Multiplying through by \\(-1\\) (just to make the coefficient of the lattice point we are focusing on positive), this equation can be written in matrix form as </p> \\[ \\begin{pmatrix} 0 &amp; 0 &amp; -1 &amp; 0 &amp; -1 &amp; 4 &amp; 0 &amp; 0 &amp; -1 \\end{pmatrix} \\begin{pmatrix} V_{1,1}\\\\ V_{2,1} \\\\ V_{3,1} \\\\ V_{1,2} \\\\ V_{2,2} \\\\ V_{3,2} \\\\ V_{1,3} \\\\ V_{2,3} \\\\ V_{3,3} \\end{pmatrix} = V_{4,2}. \\] <p>Several comments are in order: notice that the column vector of unknown potentials has length nine. This matches the fact that we don't know the potential at nine lattice points. Also note that the unknown potentials are ordered in the vector following the zig-zag arrows in the figure above. Of those nine unknowns, only four showed up in this equation and that is why only four of the numbers in the coefficient row vector are non-zero. The row vector has format 1x9 and the column vector has format 9x1 and so their product properly gives a matrix of format 1x1, in other words, a simple number. The fifth potential, in this case a known boundary value, appears on the right hand side of the equation.</p> <p>Before trying to identify the pattern in general, write out a few more example equations:</p> <p> Exercise (b): Take \\(\\Delta x = \\Delta y\\) and consider the lattice depicted in the last subsection. Pick three lattice points and write out Laplace's equation for each of them. Simplify these equations until all the unknowns are on the left and all the known, boundary values, are on the right. </p> <p> Exercise (c): Using the example at the beginning of this section, your results from (b), and the ordering of lattice points discussed in the section \"Construcing lattices in 2d\", write a code that constructs the matrix equation equivalent to Laplace's equation on the 5x5 lattice from the last section. This will include a 9x9 matrix. Rather than trying to write out all of the equations before you begin coding, use the insights you came to about the different kinds of lattice points in (b) to figure out the pattern you need to fill the matrix with. [Hint: If you have trouble identifying the matrix equation, or get stuck on how to code it up, I do the slightly more intricate 6x6 lattice as an example below.] Here you used a particular ordering of the lattice points. What would it change about the linear algebra formulation of the problem if you were to change that ordering? </p>"},{"location":"ElecMag/2DRelaxation/#solving-and-plotting-laplaces-equation-on-a-2d-lattice","title":"Solving and Plotting Laplace's Equation on a 2D Lattice","text":"<p>Of course, the number of lattice points need have nothing to do with the extension of the space that we are chopping up. Below I construct a lattice with six evenly spaced points along each axis of a square with side length one:</p> <pre><code>x,y = np.meshgrid(np.linspace(0,1,6),np.linspace(0,1,6))\n\nfig, ax = plt.subplots() \nax.plot(x,y,\"ko\") \nplt.show()\n</code></pre> <p></p> <p>Let's solve Laplace's equation on this lattice with the following boundary conditions: (i) along three of the walls, those at \\(x=0\\), \\(x=1\\), and at \\(y=0\\), the plate is grounded; and (ii) at \\(y=1\\) the potential is \\(V(x,y=1)=\\sin(\\pi x)\\).</p> <p>First we use what we learned from (c) to setup the matrix equation, and then we solve it:</p> <pre><code>M = np.zeros([16,16])       #Initialize the matrix we will eventually need to invert\nfor i in range(16):         # Fill the entries properly:\n    M[i, i] = 4             # Set the diagonals to 4.\n    if i &gt; 0:                # Begin by setting all the neighbors to the diagonals to -1.\n        M[i, i-1] = -1       # This assumes that each lattice point has a neighbor to the \n    if i &lt; 15:               # left and right, which is false and is corrected below.\n        M[i, i+1] = -1\n    if i &gt; 3:               #Once you are far enough into the lattice, always include -1\n        M[i,i-4] = -1       # for a lattice neighbor below the current site.\n    if i &lt; 12:              #As long you are not too far into the lattice, always include -1\n        M[i,i+4] = -1       # for a lattice neighbor above the current site.\n\nfor i in range(4,13):      #For lattice sites neighboring the left and right boundaries \n    if i%4==0:             #remove the left (or right, respectively) neighbor. \n        M[i,i-1]=0         #Here, the % operator gives the value of i mod 4. Like a clock\n        M[i-1,i]=0         # with only 0,1,2,3 on it, it returns 0 for any multiple of 4.\n\nprint(M)\n\nb=np.zeros(16)                            # Initialize all boundary values to zero.\nbndxs=np.linspace(0.2,0.8,4)              #Define x's along top boundary\nb[12:16]=[np.sin(np.pi*x) for x in bndxs] #Update boundary V's along top boundary\n\nprint(b)\n\n\nIntVals=linalg.inv(M)@b    #Solve for the internal potentials.\nprint(IntVals)\n</code></pre> <pre><code>[[ 4. -1.  0.  0. -1.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.]\n [-1.  4. -1.  0.  0. -1.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.]\n [ 0. -1.  4. -1.  0.  0. -1.  0.  0.  0.  0.  0.  0.  0.  0.  0.]\n [ 0.  0. -1.  4.  0.  0.  0. -1.  0.  0.  0.  0.  0.  0.  0.  0.]\n [-1.  0.  0.  0.  4. -1.  0.  0. -1.  0.  0.  0.  0.  0.  0.  0.]\n [ 0. -1.  0.  0. -1.  4. -1.  0.  0. -1.  0.  0.  0.  0.  0.  0.]\n [ 0.  0. -1.  0.  0. -1.  4. -1.  0.  0. -1.  0.  0.  0.  0.  0.]\n [ 0.  0.  0. -1.  0.  0. -1.  4.  0.  0.  0. -1.  0.  0.  0.  0.]\n [ 0.  0.  0.  0. -1.  0.  0.  0.  4. -1.  0.  0. -1.  0.  0.  0.]\n [ 0.  0.  0.  0.  0. -1.  0.  0. -1.  4. -1.  0.  0. -1.  0.  0.]\n [ 0.  0.  0.  0.  0.  0. -1.  0.  0. -1.  4. -1.  0.  0. -1.  0.]\n [ 0.  0.  0.  0.  0.  0.  0. -1.  0.  0. -1.  4.  0.  0.  0. -1.]\n [ 0.  0.  0.  0.  0.  0.  0.  0. -1.  0.  0.  0.  4. -1.  0.  0.]\n [ 0.  0.  0.  0.  0.  0.  0.  0.  0. -1.  0.  0. -1.  4. -1.  0.]\n [ 0.  0.  0.  0.  0.  0.  0.  0.  0.  0. -1.  0.  0. -1.  4. -1.]\n [ 0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0. -1.  0.  0. -1.  4.]]\n[0.         0.         0.         0.         0.         0.\n 0.         0.         0.         0.         0.         0.\n 0.58778525 0.95105652 0.95105652 0.58778525]\n[0.0363497  0.05881506 0.05881506 0.0363497  0.08658376 0.14009547\n 0.14009547 0.08658376 0.16988987 0.27488758 0.27488758 0.16988987\n 0.31808813 0.51467741 0.51467741 0.31808813]\n</code></pre> <p>The final output gives the electric potential at all of the internal points of the lattice. Our next step is to use this data to make a nice visualization of the result. In preparation, it is helpful to reshape the data so that instead of a long row of potential values, we have a clear correspondence between each potential value and a lattice point. The Python command reshape does exactly what we need, transforming a 1D array into a 2D array of specified shape:</p> <pre><code>IntValsMat = IntVals.reshape(4,4) #In order to recombine with the boundary values and for visualization,\n                                  # reshape the solution to agree with the lattice shape.\nprint(IntValsMat)\n\nVSol = np.zeros([6,6])     #Combine the solution and boundary values into one output\nVSol[1:5,1:5]=IntValsMat\nVSol[5,1:5]=b[12:16]    \nprint(VSol)\n</code></pre> <pre><code>[[0.0363497  0.05881506 0.05881506 0.0363497 ]\n [0.08658376 0.14009547 0.14009547 0.08658376]\n [0.16988987 0.27488758 0.27488758 0.16988987]\n [0.31808813 0.51467741 0.51467741 0.31808813]]\n[[0.         0.         0.         0.         0.         0.        ]\n [0.         0.0363497  0.05881506 0.05881506 0.0363497  0.        ]\n [0.         0.08658376 0.14009547 0.14009547 0.08658376 0.        ]\n [0.         0.16988987 0.27488758 0.27488758 0.16988987 0.        ]\n [0.         0.31808813 0.51467741 0.51467741 0.31808813 0.        ]\n [0.         0.58778525 0.95105652 0.95105652 0.58778525 0.        ]]\n</code></pre> <p>Finally, to visualize these data we will use a contour plot. The PyPlot library we have been using has a built-in countourf function. This function takes the points of the lattice, the potential above each point, and the number of contours as input. Here I have intentionally only plotted a few contours because I don't want to give the impression that we have solved the problem at more lattice points than we have.</p> <pre><code>x,y = np.meshgrid(np.linspace(0,1,6),np.linspace(0,1,6))\nplt.figure(figsize=(12, 6))\nplt.contourf(x, y, VSol, 10)\nplt.colorbar()\nplt.ylabel('y')\nplt.xlabel('x')\nplt.show()\n</code></pre> <p></p> <p>Exercise (d): Solve the matrix equation you setup in (c) and plot the potential, including boundary values, on a 2D contour plot. Use a small number of contours so as not to give the impression that you have found a more detailed solution than you have. If you wanted to give a higher resolution plot of the solution to this problem, what is the main ingredient in your code that you would need to change (pick just one)?</p>"},{"location":"ElecMag/BoundaryConditions/","title":"Boundary Conditions","text":"<pre><code>import numpy as np\nimport matplotlib.pyplot as plt\nimport numpy.linalg as linalg\n</code></pre> <p>At several places in previous notebooks we have noted opportunities to make the treatment of boundary conditions in Laplace's equation more involved and interesting. This notebook takes up several of these opportunities. Like most of what we've done so far, the lessons learned here apply to a wide range of PDEs, not just to Laplace's equation.</p>"},{"location":"ElecMag/BoundaryConditions/#functions-with-functions-as-input","title":"Functions with Functions as Input","text":"<p>Often a boundary condition is specified as the evaluation of a particular function along the boundary. For this reason, it is quite useful to realize that user-defined Python functions can accept functions as input. To illustrate this I'll take an example from another area. </p> <p>Suppose you wanted a Python function that took the numerical derivative of given function, \\(f(x)\\), at a user-defined point \\(x\\). Coding this is much like coding any other user-defined function. Let's suppose that our numerical derivative takes the step size, \\(h\\), the point of evaluation \\(x\\), and the function, \\(f\\), as inputs and returns the numerical derivative at \\(x\\), then we can define it as follows:</p> <pre><code>def NumD(h,x,f):\n    return (f(x+h)-f(x))/h\n</code></pre> <p>Notice the two different uses of parentheses here: the outer parentheses in the return statement are the usual grouping of terms, while the inner ones are function evaluation. Python sorts this out because it realizes when the input f is a function. Here are three examples:</p> <pre><code>def f1(x):\n    return x\n\ndef f2(x):\n    return x**2\n\ndef f3(x):\n    return np.exp(x)\n</code></pre> <p>Let's evaluate their derivatives at the origin:</p> <pre><code>print(NumD(.1,0,f1))\nprint(NumD(.1,0,f2))\nprint(NumD(.1,0,f3))\n</code></pre> <pre><code>1.0\n0.10000000000000002\n1.0517091807564771\n</code></pre> <p>And the same examples if we use a 100 times smaller step size:</p> <pre><code>print(NumD(.001,0,f1))\nprint(NumD(.001,0,f2))\nprint(NumD(.001,0,f3))\n</code></pre> <pre><code>1.0\n0.001\n1.0005001667083846\n</code></pre> <p>It is a great advantage that we can pass functions to functions. </p> <p>Exercise (a) Take the function BndyVals that you defined in the last notebook and modify it so that it takes a user-defined function as input and uses that function to evaluate the boundary conditions along the boundary \\(y=1\\). Call this new function BndyVals1 since it has an arbitrary function along one of its boundaries. (You may also want to call the input function f1, since we are going to have more input functions soon.)</p> <pre><code>def BndyVals1(Nx,Ny,f1):\n    b=np.zeros((Nx-2)*(Ny-2))                            # Initialize all boundary values to zero.\n    bndxsFull=np.linspace(0,1,Nx)              #Define x's along top boundary\n    bndxsInt=bndxsFull[1:(Nx-1)]\n    b[(Nx-2)*(Ny-2)-(Nx-2):(Nx-2)*(Ny-2)]=[f1(x) for x in bndxsInt] #Update boundary V's along top boundary\n    return b\n</code></pre>"},{"location":"ElecMag/BoundaryConditions/#length-scales","title":"Length Scales","text":"<p>We have noted a couple of times that the refinement of the lattice and the length scales of the space being discretized are independently specified. You can use 100 lattice points along a line of length 1 and you can use 10 lattice points along a line of length 100. Of course, the spacing between lattice points is quite different in these two examples, but the point is that \\(N_x\\) and \\(\\ell_x\\) are independent. </p> <p>So far the boundary condition we have been using, i.e. at \\(y=1\\) the potential is given by \\(\\sin(\\pi x)\\), has assumed that \\(\\ell_x=1\\). Let's change that now so that the boundary condition takes into account the length scale. </p> <p>A feature of this boundary condition was that the sine function vanished at \\(x=0\\) and at \\(x=1\\), which matched the other boundary conditions. How do we retain this feature if the extension in the \\(x\\)-direction is \\(\\ell_x\\)? It's not hard, we simply rescale the argument of the sine function: \\(\\sin(\\pi x/\\ell_x)\\). This again vanishes at \\(x=0\\) and when \\(x=\\ell_x\\). However, now the \\(x\\) in the argument of the sine function must have units of length; otherwise we would be taking the sine of something with units, which doesn't make sense. Previously, we noted that we can write any lattice point \\(x_i\\) as \\(i \\Delta x\\), with \\(\\Delta x\\) the spacing between lattice points. Examining a picture of a lattice, you will note that \\(\\Delta x = \\ell_x/(N_x-1)\\). Thus, evaluating our boundary value function at \\(x_i\\) gives</p> \\[ \\sin(\\pi x_i/\\ell_x) = \\sin(\\pi i \\Delta x/\\ell_x) = \\sin(i \\pi/(N_x-1)). \\] <p>(You might worry that this has the wrong value at the rightmost lattice point, but recall that \\(i\\) runs from zero up to \\(N_x-1\\), and so we again get zero at the this point.) It is striking that the length scale built in to the boundary value function and the length scale built into our lattice spacing properly cancelled out. This is a common occurrence in numerical discretizations. </p> <p>Exercise (b) Define a function fb1 that properly gives the boundary values, specified above, at \\(y=1\\) for any extension of lattice \\(\\ell_x\\). </p>"},{"location":"ElecMag/BoundaryConditions/#combining-multiple-boundary-conditions","title":"Combining Multiple Boundary Conditions","text":"<p>Up to this point we have always worked with boundary conditions that grounded three plates around the boundary of our pipe. Let's relax this condition. Once we've worked out how to make two boundaries non-vanishing, it's a simple extension to make any number of boundaries non-vanishing.</p> <p>Going back to the section \"The Structure of the Linear Algebra Problem\" in the 2DRelaxation notebook, if you worked out the case of one of the corner lattice points, e.g. \\(V_{3,3}\\), you found something like </p> \\[ \\begin{pmatrix} 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; -1 &amp; 0 &amp; -1 &amp; 4 \\end{pmatrix} \\begin{pmatrix} V_{1,1}\\\\ V_{2,1} \\\\ V_{3,1} \\\\ V_{1,2} \\\\ V_{2,2} \\\\ V_{3,2} \\\\ V_{1,3} \\\\ V_{2,3} \\\\ V_{3,3} \\end{pmatrix} = V_{3,4}+V_{4,3}. \\] <p>This shows that the two boundary values neighboring this corner lattice point add to give the total boundary condition there. This gives a simple way of treating the code: we just add in the contribution of each boundary. For example, given a pipe with boundary value function f1 along the \\(y=1\\) boundary and f2 along the \\(x=1\\) boundary, the following function gives the appropriate boundary condition. </p> <pre><code>def BndyVals2(Nx,Ny,f1,f2):\n    b=np.zeros((Nx-2)*(Ny-2))             #Initialize the b vector to zero.\n\n    bndxsFull=np.linspace(0,1,Nx)         #Define x's along top boundary\n    bndysFull=np.linspace(0,1,Ny)         #Define y's along top boundary\n    bndxsInt=bndxsFull[1:(Nx-1)]          #Exclude corners\n    bndysInt=bndysFull[1:(Ny-1)]\n\n    bndValsy=[f2(y) for y in bndysInt]    #Find V along right bndry\n\n    #Update boundary V's along top boundary\n    b[(Nx-2)*(Ny-2)-(Nx-2):(Nx-2)*(Ny-2)]=[f1(x) for x in bndxsInt] \n\n    j=(Nx-3)              #Initialize a counter to pick out the right bndry\n    for i in range(0,len(bndValsy)):     #Update V's along right bndry\n        b[j]=b[j]+bndValsy[i]\n        j += (Nx-2)\n\n    return b\n</code></pre> <pre><code>def f1(x):\n    return np.sin(np.pi*x)\n\ndef f2(y):\n    return 5\n</code></pre> <pre><code>BndyVals2(5,5,f1,f2)\n</code></pre> <pre><code>array([0.        , 0.        , 5.        , 0.        , 0.        ,\n       5.        , 0.70710678, 1.        , 5.70710678])\n</code></pre> <p>Exercise (c): Update the BndyVals2 function to a BndyVals4 function that depends on four different input functions, one for each of the four boundaries. For convenience in comparing answers, use the convention that f1 is associated to the top boundary, f2 to the right one, f3 to the bottom, and f4 to the left.</p> <p>Before closing this section, here is an example of all of the code for a relaxation problem together in one place. </p> <pre><code>def BuildM(Nx,Ny):\n    M = np.zeros([(Nx-2)*(Ny-2),(Nx-2)*(Ny-2)])\n    for i in range((Nx-2)*(Ny-2)):\n        M[i, i] = 4  \n        if i &gt; 0:                  # Begin by setting all the neighbors to the diagonals to -1.\n            M[i, i-1] = -1         # This assumes that each lattice point has a neighbor to the \n        if i &lt; ((Nx-2)*(Ny-2)-1):  # left and right, which is false and is corrected below.\n            M[i, i+1] = -1\n        if i &gt; (Nx-3):               #Once you are far enough into the lattice, always include -1\n            M[i,i-(Nx-2)] = -1       # for a lattice neighbor below the current site.\n        if i &lt; ((Nx-2)*(Ny-2)-(Nx-2)):              #As long you are not too far into the lattice, always include -1\n            M[i,i+(Nx-2)] = -1       # for a lattice neighbor above the current site.\n\n    for i in range((Nx-2),(Nx-2)*(Ny-2)-(Nx-3)):      #For lattice sites neighboring the left and right boundaries \n        if i%(Nx-2)==0:             #remove the left (or right, respectively) neighbor. \n            M[i,i-1]=0         #Here, the % operator gives the value of i mod 4. Like a clock\n            M[i-1,i]=0         # with only 0,1,2,3 on it, it returns 0 for any multiple of 4.\n    return M\n\ndef BndyVals2(Nx,Ny,f1,f2):\n    b=np.zeros((Nx-2)*(Ny-2))             #Initialize the b vector to zero.\n\n    bndxsFull=np.linspace(0,1,Nx)         #Define x's along top boundary\n    bndysFull=np.linspace(0,1,Ny)         #Define y's along top boundary\n    bndxsInt=bndxsFull[1:(Nx-1)]          #Exclude corners\n    bndysInt=bndysFull[1:(Ny-1)]\n\n    bndValsy=[f2(y) for y in bndysInt]    #Find V along right bndry\n\n    #Update boundary V's along top boundary\n    b[(Nx-2)*(Ny-2)-(Nx-2):(Nx-2)*(Ny-2)]=[f1(x) for x in bndxsInt] \n\n    j=(Nx-3)              #Initialize a counter to pick out the right bndry\n    for i in range(0,len(bndValsy)):     #Update V's along right bndry\n        b[j]=b[j]+bndValsy[i]\n        j += (Nx-2)\n\n    return b\n\ndef RelaxLaplace(Nx,Ny,f1,f2):\n    M=BuildM(Nx,Ny)\n    b=BndyVals2(Nx,Ny,f1,f2)\n\n    IntVals=linalg.inv(M)@b\n    IntValsMat = IntVals.reshape(Ny-2,Nx-2) #In order to recombine with the boundary values and for visualization,\n                                  # reshape the solution to agree with the lattice shape.\n\n    VSol = np.zeros([Ny,Nx])     #Combine the solution and boundary values into one output\n    VSol[1:Ny-1,1:Nx-1]=IntValsMat\n    VSol[Ny-1,1:Nx-1]=b[(Nx-2)*(Ny-2)-(Nx-2):(Nx-2)*(Ny-2)]  \n    return VSol\n</code></pre>"},{"location":"ElecMag/BoundaryConditions/#making-3d-surface-plots","title":"Making 3D Surface Plots","text":"<pre><code>from mpl_toolkits import mplot3d\n</code></pre> <p>The contour plots that we have been using up to this point are great, but sometimes you want a more direct visual sense of how your function changes, and 3D surface plots can be useful for this. The Matplotlib library has built in functions for this purpose as well. Above we have imported the Matplotlib 3D functionality. This works quite similarly to a contour plot, except that you use a \\(z\\)-height to display the values of the function that you are plotting. Below I use our standard example from the last few notebook, with three of the walls of the pipe grounded and the last one subject to a sine wave potential.</p> <pre><code>def f1(x):\n    return np.sin(np.pi*x)\n\ndef f2(y):\n    return 0\n</code></pre> <pre><code>fig = plt.figure(figsize = (28,8))\nax = plt.axes(projection='3d')\n\nX,Y = np.meshgrid(np.linspace(0,1,70),np.linspace(0,1,50))\n\nZ = RelaxLaplace(70,50,f1,f2)\n\nsurf = ax.plot_surface(X, Y, Z, cmap = plt.cm.cividis) #The last argument specifies the colormap \n                                                       #associated with each function height\n\n# Set axes label\nax.set_xlabel('x', labelpad=20)\nax.set_ylabel('y', labelpad=20)\nax.set_zlabel('V(x,y)', labelpad=20)\n\nfig.colorbar(surf, shrink=0.5, aspect=15) #This adds a colorbar, giving the quantitative \n                                         #correspondence between colors and heights\n\nplt.show()\n</code></pre> <p></p> <p>Exercise (d): Take the case with \\(f_1(x)=f_3(x)=0\\) and \\(f_2(y)=f_4(y)=1\\) and use your new BndyVals4 function to solve Laplace's equation in the pipe numerically. Make the usual contour plot of your solution, but also make a 3D plot along the lines above and compare your result to Griffiths' Fig. 3.21.</p>"},{"location":"ElecMag/Discretization1D/","title":"Discretization in One Dimension","text":"<pre><code>import matplotlib.pyplot as plt\nimport numpy as np\n</code></pre> <p>A helpful intuition in the study of Laplace's equation</p> \\[ \\nabla^2 V = 0 \\] <p>is to realize that the solutions always have the averaging property. This property can even be turned into a numerical technique for solving Laplace\u2019s equation, the method of relaxation. This is a delightful and accessible numerical technique for solving certain partial differential equations (PDEs) that we will work on in the next few notebooks.</p> <p>In the end this method is very simple, but there are several numerical steps that won\u2019t appear intuitive until you have derived them yourself. The main ingredient\u2014to understand and develop notation for\u2014is discretization. You've used discretization in solving Ordinary Differential Equations (ODEs), e.g. for Euler's method, and in plotting vector fields, but here we will focus on this process explicitly. </p>"},{"location":"ElecMag/Discretization1D/#one-dimensional-discretization","title":"One-dimensional discretization","text":"<p>A discretization cuts a smooth, continuous space into pieces. At first we will always take these pieces to have the same size. A simple example is the elementary number line plotted below. The discretization chops the black line into a set of evenly spaced, red points.</p> <pre><code>latticepts = np.linspace(-5,5,11) #Setup the points of the discretization\nyvals = np.zeros_like(latticepts) #In 1D give them no y heights\n\nfig, ax = plt.subplots() #Setup figure\n\nax.plot(latticepts,yvals,\"ro\",latticepts, yvals, '-k') #Make plot\n\nratio = 0.2 #The next few lines adjust the aspect ratio for our 1D plot\nx_left, x_right = ax.get_xlim()\ny_low, y_high = ax.get_ylim()\nax.set_aspect(abs((x_right-x_left)/(y_low-y_high))*ratio)\n\nplt.xticks(latticepts) #Show ticks and labels at all lattice pts\nplt.tick_params(left = False, labelleft = False) #Remove vertical ticks/labels\n\nplt.show()\n</code></pre> <p></p> <p>The idea of the discretization is to study the electric potential \\(V\\) not at every point of the black line, but only at the discrete set of values denoted by the red points. It will be quite useful to have some notation that allows us to refer to the points of the discretization. If we think of the black line as the \\(x\\)-axis, then we can refer to an arbitrary red point using the symbol \\(x_i\\). Here the subscript \\(i\\) varies over the integers and picks out which lattice point we are referring to. The lattice points \\(x_{-4}\\) and \\(x_{3}\\) are shown in the plot below.</p> <pre><code>fig, ax = plt.subplots() #Same setup as above...\n\nax.plot(latticepts,yvals,\"ro\",latticepts, yvals, '-k') \nax.set_aspect(abs((x_right-x_left)/(y_low-y_high))*ratio)\nplt.xticks(latticepts) \nplt.tick_params(left = False, labelleft = False) \n\n#...but, this snippet adds text to the plot\nax.text(.76, 0.65, \"$x_3$\",c='red', fontsize=16, transform=ax.transAxes)\nax.text(.1, 0.65, \"$x_{-4}$\",c='red', fontsize=16, transform=ax.transAxes)\n\nplt.show()\n</code></pre> <p></p> <p>Using a bit of notational cleverness, we can also develop a shorthand for the value of the electric potential at the point \\(x_i\\): we simply use the same subscript convention again and define \\(V_i \\equiv V(x_i)\\). It is much easier to do calculations with the compact expression \\(V_i\\) than with the more cumbersome \\(V(x_i)\\). </p> <p>Let's use this new notation to find a discrete approximation to the derivative \\(dV/dx\\). At the point \\(x_i\\), this derivative is defined by</p> \\[ \\frac{dV}{dx} = \\lim_{h \\rightarrow 0} \\frac{V(x_i+h)-V(x_i)}{h}. \\] <p>To make a discrete approximation of this quantity we will simply drop the limit and take the step size \\(h\\) to be fixed. In particular, this means that \\(x_i+h\\) is one step to the right of \\(x_i\\) and is \\(x_{i+1}\\). Our approximation is then,</p> \\[ \\frac{dV}{dx} \\approx \\frac{V(x_{i+1})-V(x_i)}{h} = \\frac{V_{i+1}-V_i}{h}. \\] <p>The writing saved in the last expression can be quite substantial when you are doing manipulations by hand. </p> <p> Exercise (a): Find a discretization for \\(d^2 V/dx^2\\). Your answer should be in terms of \\(V_{i+1}, V_i, V_{i-1}\\) and \\(h^2\\). [Hint: Recall that you can always think of a 2nd derivative as</p> <p>$$ \\frac{d^2 V}{dx^2} = \\frac{d}{dx}\\left(\\frac{dV}{dx} \\right).  $$ This means that you can find a discretization for the 2nd derivative by applying the one for the first derivative twice. It will be helpful to give \\(dV/dx\\) a name, like \\(W(x) = dV/dx\\), and discretize the outer derivative first, only after that putting in the definition of \\(W\\).]</p> <p> Exercise (b): Use your answer to (a) to find a numerical approximation to the second derivative of \\(\\sin(x)\\) in the interval \\([0,2\\pi)\\) for step sizes \\(h\\in\\{2\\pi/10,2\\pi/100,2\\pi/1000\\}\\). Plot the exact answer together with your numerical approximations.</p>"},{"location":"ElecMag/Discretization1D/#solving-laplaces-equation-in-one-dimension","title":"Solving Laplace's equation in one-dimension","text":"<p>In the final exercise you will develop a method to numerically solve Laplace's equation on a 1D discretization. Using your result from (a), Laplace's equation on three neighboring lattice points is approximately given by </p> \\[ \\frac{V_{i+1}-2 V_i+V_{i-1}}{h^2} = 0.  \\] <p>Solving this equation for \\(V_i\\) gives</p> \\[\\begin{equation*} V_i = \\frac{V_{i+1}+V_{i-1}}{2}. \\label{LapEq} \\tag{1} \\end{equation*}\\] <p>This says that at each lattice point \\(x_i\\) the value of the potential is equal to the average of the two neighboring values, which is just a discrete version of the averaging property! Remarkably, the step size, \\(h\\), has disappeared. </p> <p>For equations like Laplace's we often don't specify two initial conditions at one point, but instead specify one boundary condition at each point on the boundary of the region we are trying to solve it in. For the case of the 1D lattice introduced at the beginning of this notebook this means that we should be given the value of the potential at \\(x_{-5}\\) and at \\(x_{5}\\) and we will not update these values. (People typically call these Dirichlet boundary conditions.) </p> <p>The idea of the method of relaxation is to use Eq. \\(\\eqref{LapEq}\\) to solve for all the values of \\(V_i\\) away from the boundary. Notice, however, that using this equation to find \\(V_{-4}\\) involves the value of \\(V_{-3}\\), specifically,</p> \\[ V_{-4} = \\frac{V_{-3}+V_{-5}}{2}, \\] <p>and we don't yet know \\(V_{-3}\\).  To get around this issue we begin by assigning arbitrary initial values to all the interior lattice points, then use Eq. \\(\\eqref{LapEq}\\) to update the values on the interior. A first pass through all the interior points will update some of their values and this means that they will change again on a second pass through. The name of the method comes from the fact that as you repeatedly run through the points, they will eventually \"relax\" to values that are either no longer changing, or changing by less and less.</p> <p>The code below illustrates a simple implementation of this method for the case where \\(V_{-5} = -4\\) and \\(V_5 = 4\\). As mentioned above, the interior points can be given arbitrary initial values. However, if the initial values are huge compared to the true solution it will take the method a long time to relax to the true values. For this reason it is wise to pick values that are not \"too far\" from the solution. Again, the intuition of the averaging property helps in coming up with a strategy. We will simply assign the average of the boundary values as the initial condition for all the interior points. These initial values shouldn't be too far from the solution. </p> <pre><code>latticepts = np.linspace(-5,5,11)   #Setup the points of the discretization\nVinit=-4                            #The boundary values\nVfin=4\nBndAve = (Vfin+Vinit)/2             #The initial values for internal points\n\nVvals = np.zeros_like(latticepts)   #Setup an array of potential values and fill it\nVvals[0]=Vinit\nVvals[1:10]=BndAve                  #Recall that the slice only goes up to the right end minus one\nVvals[10]=Vfin\n\nprint(Vvals)\n\nfor i in range(100):                        #Iteration for the passes through the discretization\n    Nvals = np.zeros_like(latticepts)       #Setup an array to store new computed values\n    for j in range(9):                      #Compute new values\n        Nvals[j+1]=(Vvals[j]+Vvals[j+2])/2  \n    Vvals[1:10]=Nvals[1:10]                 #Update the potential values with computed vales for this pass\n\n\n    if i&lt;5:                              #A crude method for displaying the output that you should improve\n        print(Vvals)                     #Print the values for the first few passes\n    if i==5:\n        print(\"********\")\n    if i&gt;92: \n        print(Vvals)                    #Print the values for the last few passes\n</code></pre> <pre><code>[-4.  0.  0.  0.  0.  0.  0.  0.  0.  0.  4.]\n[-4. -2.  0.  0.  0.  0.  0.  0.  0.  2.  4.]\n[-4. -2. -1.  0.  0.  0.  0.  0.  1.  2.  4.]\n[-4.  -2.5 -1.  -0.5  0.   0.   0.   0.5  1.   2.5  4. ]\n[-4.   -2.5  -1.5  -0.5  -0.25  0.    0.25  0.5   1.5   2.5   4.  ]\n[-4.    -2.75  -1.5   -0.875 -0.25   0.     0.25   0.875  1.5    2.75\n  4.   ]\n********\n[-4.         -3.2        -2.4        -1.59999999 -0.8         0.\n  0.8         1.59999999  2.4         3.2         4.        ]\n[-4.  -3.2 -2.4 -1.6 -0.8  0.   0.8  1.6  2.4  3.2  4. ]\n[-4.  -3.2 -2.4 -1.6 -0.8  0.   0.8  1.6  2.4  3.2  4. ]\n[-4.  -3.2 -2.4 -1.6 -0.8  0.   0.8  1.6  2.4  3.2  4. ]\n[-4.  -3.2 -2.4 -1.6 -0.8  0.   0.8  1.6  2.4  3.2  4. ]\n[-4.  -3.2 -2.4 -1.6 -0.8  0.   0.8  1.6  2.4  3.2  4. ]\n[-4.  -3.2 -2.4 -1.6 -0.8  0.   0.8  1.6  2.4  3.2  4. ]\n</code></pre> <p>Exercise (c): Turn the algorithm above into a function called MethRelax1D that allows you to adjust the number of lattice points N, the boundary values Vinit and Vfin, and the number of passes through the lattice. (Note: you will need to think about how to treat different input values of N.) Use MethRelax1D  to find a numerical solution to Laplace's equation in one dimension, \\(d^2 V/dx^2=0\\), on the interval \\(x \\in [-7,7]\\).  Take \\(V_{-7} = -4\\) and \\(V_7 = 9\\) as boundary conditions. You needn't print out passes through the lattice, but implement a way to be sure that your answer has \"converged\", that is, that it isn't changing much in the last few passes. Plot your numerical result and comment on whether it agrees with the analytical solution, which can be worked out quite explicitly in 1D.</p> <p>You will have notice that in the first several passes the values of several of the interior points don't change. This algorithm is not as efficient as it could be in many ways. We'll explore how to improve it next time.</p>"},{"location":"ElecMag/EulersMethod/","title":"Introduction to Numerical Solution of Differential Equations: Euler's Method","text":"<pre><code>import numpy as np\nimport matplotlib.pyplot as plt\n</code></pre>"},{"location":"ElecMag/EulersMethod/#eulers-idea","title":"Euler's Idea","text":"<p>The mathematician Leonard Euler developed a wonderful and intuitive method for solving first order differential equations. Suppose we are given the differential equation</p> \\[ \\dot{x}(t) \\equiv \\frac{dx}{dt}(t)=f(t, x(t)), \\] <p>with \\(f(t, x(t))\\) a given function. The idea is simply to approximate the derivative as a finite difference:</p> \\[ \\frac{dx}{dt}(t) = \\lim_{h \\rightarrow 0} \\frac{x(t+h)-x(t)}{h} \\approx \\frac{x(t+h)-x(t)}{h}, \\] <p>where the approximation holds for finite, but small \\(h\\). Using this result,</p> \\[ \\dot{x}(t) \\approx \\frac{x(t+h)-x(t)}{h}, \\] <p>we can algebraically solve for \\(x(t+h)\\). The solution is </p> <p>$$ x(t+h) \\approx h \\cdot \\dot{x}(t) +x(t) = h \\cdot f(t, x(t))+x(t). $$ In this way we have found the position after a time step \\(h\\) has elapsed, \\(x(t+h)\\), from the position at our initial time \\(x(t)\\).</p> <p>In the final formula we are supposed to think of \\(f(t, x(t))\\) as given when the differential equation was first specified. This means that once we are given an initial value of \\(x(t)\\) at some time, we can successively find it after one time step \\(h\\), then after another step and another and so on. This gives us \\(x(t)\\) for all future times. </p> <p>Below I use a simple differential equation as an example of this technique. It is valuable to first solve this equation analytically, so that you have something with which to compare the numerics.</p> <p>Exercise (a): Solve the first order differential equation \\(\\dot{x} = -\\lambda x\\) using separation of variables, subject to the initial condition \\(x(0) = x_0\\). Again the shorthand \\(\\dot{x}\\) just means \\(\\dot{x} \\equiv dx/dt\\).</p>"},{"location":"ElecMag/EulersMethod/#implementing-the-algorithm","title":"Implementing the algorithm","text":"<p>Suppose we want to solve this equation numerically</p> <p>$$ \\dot{x}(t) = - \\lambda x(t),  $$ and that it is subject to the initial condition \\(x(0) = 10\\) and has \\(\\lambda=2\\). Let's pick a small time step, say \\(h=0.25\\), and evolve this initial condition. Stepping from \\(t=0\\) to \\(t=0.25\\), i.e. following one time step, we have </p> \\[ x(0+0.25) = 0.25 \\cdot \\dot{x}(0)+x(0) = 0.25 \\cdot (-\\lambda x(0))+x(0) = 0.25 \\cdot (-2 (10))+10 = 5.  \\] <p>We could repeat this process again and again, but clearly that is a task for a computer. So, let's write a code to do it. </p> <p>First we need to break the full time interval into steps:</p> <pre><code>tvals = np.linspace(0.,10.,41)\nprint(tvals[0])\nprint(tvals[1])\n</code></pre> <pre><code>0.0\n0.25\n</code></pre> <p>Notice that because linspace includes the left endpoint, I needed to ask for 41, not 40 points for this to work. </p> <p>Now we can use our numerical integration scheme from above:</p> <pre><code>tvals = np.linspace(0.,10.,41)\nx = np.zeros(len(tvals))\nx[0]=x0=10\nlam=2\nh=0.25\nfor i in range(len(tvals)-1):\n    x[i+1]=h*(-lam*x[i])+x[i];\n\nplt.figure(figsize=(10,5))\nplt.plot(tvals,x, 'k-', label=\"numerical curve\")\nplt.legend(loc=\"upper left\")\nplt.ylabel('position x(t)',fontsize=20)\nplt.xlabel('time t',fontsize=20)\nplt.title('Euler Method Result',fontsize=20)\nplt.xlim(0, 10)\nplt.ylim(0, 11)\nplt.show()\n</code></pre> <p></p> <p>Exercise (b): Plot the result of the numerical code above together with your analytical solution from part (a). Why doesn't the numerical code agree with your analytical solution very well? Adjust the code so that it gives a much better agreement. [Hint: I've chosen a large step size. You'll have to adjust the code in a couple of places to give yourself a more reasonable step size.]</p> <p>Exercise (c): Wonderfully, unlike the analytical methods that we often study, these numerical techniques can immediately be used to solve nonlinear differential equations. Solve the differential equation</p> \\[ \\dot{x}(t) =  x^2 \\] <p>using the Euler method. Take the initial condition \\(x(0)=0.1\\). </p> <p>Because this equation is first order, you can also solve it analytically, although you can't use the standard, exponential, guess. Solve this equation using separation of variables and integration and compare your analytical to your numerical solution. </p>"},{"location":"ElecMag/PythonJupyterPlottingVectorFields/","title":"Plotting Vector Fields in Python","text":"<p>Python's matplot library, matplotlib, has all the functions you need to compute and plot vector fields. We'll be using the numpy function meshgrid to make a two-dimensional array of points at which to plot the arrows and matplotlib's quiver function to create the vectors. </p> <p>The quiver function has two different types of inputs. The first two inputs are the \\(x\\) and \\(y\\) coordinates where the vectors will be plotted and the last two are the functions that determine the components of the vectors at those points.</p> <p>Below are a few examples to give you a feel for using these functions followed by some exercises for you to try. </p> <p>Example 1: Plot the vector field \\(\\vec{V}(x,y) = \\hat{x}-\\hat{y}\\). </p> <pre><code>import numpy as np\nimport matplotlib.pyplot as plt\nfig, ax = plt.subplots() #Setup figure\n\nx,y = np.meshgrid(np.linspace(-5,5,10),np.linspace(-5,5,10))\n\nu = 1\nv = -1\n\nplt.quiver(x,y,u,v)\nplt.xlabel('$x$')\nplt.ylabel('$y$')\nplt.show()\n</code></pre> <p></p> <p>The linspace function makes an array of values starting at its first argument and ending at its second argument with as many values as its final argument. Copy and past the above code and try adjusting these parameters. You'll notice that quiver automatically adjusts the size of the arrows depending on how many you display. </p> <p>Example 2: Here's a less simple example where the components of the vector field depend on position, \\(\\vec{V}(x,y) = y \\hat{x} - xy \\hat{y}\\). </p> <pre><code>x,y = np.meshgrid(np.linspace(-5,5,10),np.linspace(-5,5,10))\nfig, ax = plt.subplots() #Setup figure\n\nu = y\nv = -x*y\n\nplt.quiver(x,y,u,v)\nplt.xlabel('$x$')\nplt.ylabel('$y$')\nplt.show()\n</code></pre> <p></p> <p>Exercise (a): Consider the \\(xy\\) plane in polar coordinates \\((r,\\phi)\\). Find the polar unit vector \\(\\hat{r}\\) in Cartesian coordinates. (N.B. This is a vector field and depends on which point of the plane you are at.) Plot your result and confirm that it makes sense. </p> <p>Exercise (b): Same setup as in 1. Find the unit vector \\(\\hat{\\phi}\\) in Cartesian coordinates. Plot your result and confirm that it makes sense. </p> <p>Excercise (c): Take any of the three-dimensional vector fields that you have worked with in the first two problem sets or read about in the first chapter of Griffiths. Evaluate this vector field in the \\(xy\\) plane, and then project it onto the \\(xy\\) plane. Finally make a plot of your result using the tools above. (Here I want you to think through what it means to evaluate the vector field in the \\(xy\\) plane and what it means to project it onto this plane. You should identify the mathematical procedures that accomplish each of these things and what they mean geometrically. Explain your procedures and what they mean briefly in English too.)</p>"},{"location":"ElecMag/PythonJupyterPlottingVectorFields2/","title":"Plotting Electric Fields in Python","text":"<p>As we've seen in class, when dealing with a finite set of point charges there is a simple, constructive way to compute the electric field of these charges: you just add up the electric fields of each of the charges. It's not too difficult to turn this construction into a function in python. I've done that here: </p> <pre><code>import numpy as np\nimport matplotlib.pyplot as plt\n\n#When a function definition has an argument like charges=[1], the value after the equal sign will be the default\n#value of that argument when evaluating the function. Here this means that the default is a single charge at the \n#origin with q=1. \ndef elec_field(x, y, x_coords=[0], y_coords=[0], charges=[1]):\n    Ex = np.zeros_like(x)\n    Ey = np.zeros_like(x)\n    for x0, y0, q in zip(x_coords, y_coords, charges):\n        scrR = np.sqrt((x - x0)**2 + (y - y0)**2) + 1e-6 #The 1e-6 is a simple way to avoid ever dividing by zero.\n        Ex += q*(x - x0)/scrR**3\n        Ey += q*(y - y0)/scrR**3\n    return Ex, Ey\n</code></pre> <p>The first two inputs are the \\(x\\) and \\(y\\) coordinates of the points where the electric field will be computed, the field points. The next two arguments are arrays giving the \\(x\\) and \\(y\\) coordinates of each charge in the distribution. The last argument is an array that gives the charge of each particle in the distribution (including its sign). </p> <p>The zip function combines the three arrays of its arguments so that the for loop can run over each of their entries in one simple object. The for loop runs over each charge and computes its electric field at each field point and adds them up. </p> <p>Below I use this function to compute and plot the electric vector field of two point charges, one positive and one negative. I use essentially the same strategy as last week. The numpy function mgrid gives an array of evenly spaced point, here from -3 to 3 in the \\(x\\) direction and from -3 to 3 in the \\(y\\) direction, with 21 evenly spaced points in each direction. </p> <pre><code>y, x = np.mgrid[-3:3:21j, -3:3:21j]\nEx, Ey = elec_field(x, y, x_coords=[-1, 1], y_coords=[0,0],charges=[1, -1])\ncomp_x = Ex\ncomp_y = Ey\n\nfig, ax = plt.subplots(figsize=(9, 9)) \nplt.quiver(x, y, comp_x, comp_y,\n           scale_units=\"inches\", scale=2, width=0.005, pivot=\"mid\")\nplt.xlabel('$x$',fontsize=14)\nplt.ylabel('$y$',fontsize=14)\nplt.axis(\"image\")\n\n#plt.savefig(\"vector_field.png\", dpi=300)\nplt.show()\n</code></pre> <p></p> <p>The trouble is that this doesn't look very good. This is because the magnitude of the field increases near the charges, the field vectors get very large and cross all over each other.</p> <p>An alternative strategy is to use the vector field arrows to indicate the direction of the field, but normalize them so that they are always the same length. This way they won't cross, but we lose the information about the magnitude of the electric field. We can add the magnitude information back in by making the background colored. I'll use a contour plot to do that. Let's also add a plot title to further clarify what we are doing.</p> <pre><code>y, x = np.mgrid[-3:3:17j, -3:3:17j]\nEx, Ey = elec_field(x, y, x_coords=[-1, 1], y_coords=[0,0],\n                    charges=[1, -1])\nEmag = np.sqrt(Ex**2 + Ey**2)\ndir_x = Ex/Emag\ndir_y = Ey/Emag\n\n\nfig, ax = plt.subplots(figsize=(11, 11)) \nplt.contourf(x, y, Emag,  15, cmap=\"summer\")\nplt.colorbar()\nplt.quiver(x, y, dir_x, dir_y,\n           scale_units=\"inches\", scale=2.4, width=0.005, pivot=\"mid\")\nplt.xlabel('$x$',fontsize=14)\nplt.ylabel('$y$',fontsize=14)\nplt.title('The electric field of a positive and a negative point charge', fontsize=15)\nplt.axis(\"image\")\n\n#plt.savefig(\"vector_field.png\", dpi=300)\nplt.show()\n</code></pre> <p></p> <p>This looks much better, but still has problems. One issue is that the contours look very polygonal. This is because we aren't computing the field at enough points. We can fix it by increasing the number of points in mgrid. But, that will cover the whole region in arrows. </p> <p>The trick to fix that is to compute the field at all the points and only plot the vectors at a subset of the points. We can do the latter by \"slicing\" the arrays of field points and only keeping half of them. You can keep a fraction of the points in an array using the slicing :: , for example x[::3,::3] picks out every third point in the x array. </p> <pre><code>y, x = np.mgrid[-3:3:45j, -3:3:45j]\nEx, Ey = elec_field(x, y, x_coords=[-1, 1], y_coords=[0,0],\n                    charges=[1, -1])\nEmag = np.sqrt(Ex**2 + Ey**2)\ndir_x = Ex/Emag\ndir_y = Ey/Emag\n\n\nfig, ax = plt.subplots(figsize=(11, 11)) \nplt.contourf(x, y, Emag,  33, cmap=\"summer\")\nplt.colorbar()\nplt.quiver(x[::3, ::3], y[::3, ::3], dir_x[::3, ::3], dir_y[::3, ::3],\n           scale_units=\"inches\", scale=2.4, width=0.005, pivot=\"mid\")\nplt.xlabel('$x$',fontsize=14)\nplt.ylabel('$y$',fontsize=14)\nplt.title('The electric field of a positive and a negative point charge', fontsize=15)\nplt.axis(\"image\")\n\n#plt.savefig(\"vector_field.png\", dpi=300)\nplt.show()\n</code></pre> <p></p> <p>We're getting there, but the magnitude information still isn't very helpful. It's for the same reason as before. The field gets huge right near the charges, but then drops off rapidly. The upshot is that all the contours are right near the charges. </p> <p>A way around this is to use the logarithm of the magnitude to make the contour plot. This flattens out the contour plot. This makes the information much easier to read, but should be accompanied by a warning for your reader!</p> <pre><code>y, x = np.mgrid[-3:3:48j, -3:3:48j]\nEx, Ey = elec_field(x, y, x_coords=[-1, 1], y_coords=[0,0],\n                    charges=[1, -1])\nEmag = np.sqrt(Ex**2 + Ey**2)\ndir_x = Ex/Emag\ndir_y = Ey/Emag\n\n\nfig, ax = plt.subplots(figsize=(11, 11)) \nplt.contourf(x, y, np.log10(Emag),  33, cmap=\"summer\")\nplt.colorbar()\nplt.quiver(x[::3, ::3], y[::3, ::3], dir_x[::3, ::3], dir_y[::3, ::3],\n           scale_units=\"inches\", scale=2.4, width=0.005, pivot=\"mid\")\nplt.xlabel('$x$',fontsize=14)\nplt.ylabel('$y$',fontsize=14)\nplt.title('The electric field of a positive and a negative point charge', fontsize=15)\nplt.figtext(0.5, 0.05, 'Warning: magnitude contours have been logarithmically rescaled to aid visualization', wrap=True, horizontalalignment='center', fontsize=15)\n\nplt.axis(\"image\")\n\n#plt.savefig(\"vector_field.png\", dpi=300)\nplt.show()\n</code></pre> <p></p> <p>Exercise (a): Plot the electric vector field and magnitude of three charges sitting at the vertices of an equilateral triangle. Give two of the charges \\(q=+1\\) and the last charge \\(q=-1\\). </p> <p>Exercise (b): Plot the electric field of 4 charges sitting at the corners of a square with vertices \\((-1,-1), (-1,1), (1,-1)\\), and \\((1,1)\\). Setup the charges with alternate signs at each corner.</p>"},{"location":"ElecMag/RefiningRelaxation/","title":"Refining Relaxation","text":"<pre><code>import numpy as np\nimport matplotlib.pyplot as plt\nimport numpy.linalg as linalg\n</code></pre>"},{"location":"ElecMag/RefiningRelaxation/#what-is-refinement","title":"What is Refinement?","text":"<p>At the end of the last notebook we noticed that if we wanted to make nicer plots of the potential in a 2D region that we were going to have to compute the potential on lattices with more and more points. When you don't change the extension of a space that you are discretizing, but you increase the number of lattice points in its discretization, we call that making a finer lattice and the process refinement. For the example of the 2D square and rectangular lattices we have been considering, this means that we keep \\(\\ell_x\\) and \\(\\ell_y\\) fixed while increasing the number of lattice points, \\(N_x\\) and \\(N_y\\), in each direction. </p> <p>So far, we have written code that computes the solution to Laplace's equation on a single fixed 2D lattice. Our task in this notebook, then, is to write a function that will solve the equation on a lattice with a user specified number of lattice points. Let's break this into manageable steps.</p> <p>Refer back to the 2DRelaxation notebook as often as you need to in solving the exercises below. </p>"},{"location":"ElecMag/RefiningRelaxation/#refinement-in-practice","title":"Refinement in Practice","text":"<p>Exercise (a): Define a function called plot_lat that takes the number of lattice points in the \\(x\\)- and \\(y\\)-directions, \\(N_x\\) and \\(N_y\\), as well as the length of the space in the \\(x\\)- and \\(y\\)-directions, \\(\\ell_x\\) and \\(\\ell_y\\), as input, and plots a lattice with those properties. Design the function so that the default inputs for \\(\\ell_x\\) and \\(\\ell_y\\) are both 1. </p> <p>Exercise (b): Before moving on, update your plot_lat function so that it colors the internal lattice points and those on the boundary different colors. It's fine to do this in the somewhat crude way that I did in the previous notebook, that is, to plot all the lattice points with one color and then to plot over that with only the internal lattice points in a different color.</p> <p>The real point of this exercise is to understand how to pick out the internal lattice points. One way to do this is to define xin as some slicing of x and yin as some slicing of y. You will need to think carefully about what these slicings are. This will be valuable for the exercises below.</p> <p>Exercise (c): Define a function called BuildM that takes the number of lattice points in the \\(x\\)- and \\(y\\)-directions, \\(N_x\\) and \\(N_y\\), as input, and fills in the matrix \\(M\\) of coefficients of the linear equation you will need to solve for relaxation. This matrix should only involve the interior points of the lattice and so it does not have dimensions \\((N_x\\cdot N_y) \\times (N_x \\cdot N_y)\\). Before you begin programming work out what dimensions it does have. Use the \\(M\\) of the \\(5\\times 5\\) lattice you worked on in the last notebook as an example to help you generalize to this case. Test your new function by making sure that it reproduces the correct \\(M\\) for the \\(5\\times5\\) lattice. </p> <p>Exercise (d): Define a function called BndyVals that takes the number of lattice points in the \\(x\\)- and \\(y\\)-directions, \\(N_x\\) and \\(N_y\\), as input, and fills in the boundry value vector \\(b\\) on the right side of the linear equation you will need to solve for relaxation.  For this excercise, use the same boundary conditions as in the last notebook, namely: (i) along three of the walls, those at \\(x=0\\), \\(x=1\\), and at \\(y=0\\), the plates are grounded; and (ii) at \\(y=1\\) the potential is \\(V(x,y=1)=\\sin(\\pi x)\\). (You might notice that, for simplicity, at this point we are assuming \\(\\ell_x=1\\). You will generalize this aspect of the problem in the next notebook.)</p> <p>Exercise (e): Define a function called RelaxLaplace that sets up and solves the 2D relaxation problem for Laplace's equation using your BuildM and BndyVals functions.  Take this function to have \\(N_x\\) and \\(N_y\\) as inputs and again use the boundary conditions: (i) along three of the walls, those at \\(x=0\\), \\(x=1\\), and at \\(y=0\\), the plates are grounded; and (ii) at \\(y=1\\) the potential is \\(V(x,y=1)=\\sin(\\pi x)\\). When combining your solution to the linear algebra problem and the boundary values you will need to use the reshape function, and this is where having thought through the slicing of the arrays setup by meshgrid will be valuable.</p> <p>Exercise (f): Plot the potential you obtained in exercise (e), including boundary values, on a 2D contour plot. You no longer need to use a small number of contours as you can find your solution on as refined a lattice as you like. Compare your plot to that from exercise (d) of the 2DRelaxation notebook solution. Are you satisfied that your new result is simply a higher resolution version of the previous one? </p>"},{"location":"ElecMag/RelaxationWithLinearAlgebra/","title":"Relaxation With Linear Algebra","text":"<pre><code>import matplotlib.pyplot as plt\nimport numpy as np\n</code></pre>"},{"location":"ElecMag/RelaxationWithLinearAlgebra/#converting-relaxation-into-linear-algebra","title":"Converting Relaxation Into Linear Algebra","text":"<p>Before proceeding to higher dimensions, where relaxation methods are more valuable, we will work out another way of formulating the relaxation problem. The idea is to observe that the discrete Laplace equations we found can be turned into a linear system of equations, which can be solved very efficiently using linear algebra. </p> <p>Consider the 4-point lattice shown below:</p> <pre><code>latticepts = np.linspace(0,3,4) #Setup the points of the discretization\nyvals = np.zeros_like(latticepts) #In 1D give them no y heights\n\nfig, ax = plt.subplots() #Setup figure\n\nax.plot(latticepts,yvals,\"ro\",latticepts, yvals, '-k') #Make plot\n\nratio = 0.2 #The next few lines adjust the aspect ratio for our 1D plot\nx_left, x_right = ax.get_xlim()\ny_low, y_high = ax.get_ylim()\nax.set_aspect(abs((x_right-x_left)/(y_low-y_high))*ratio)\n\nplt.xticks(latticepts) #Show ticks and labels at all lattice pts\nplt.tick_params(left = False, labelleft = False) #Remove vertical ticks/labels\n\nplt.show()\n</code></pre> <p></p> <p>Fix the boundary values \\(V_0\\) and \\(V_3\\) for the potential on this lattice. There are then only two unknowns \\(V_1\\) and \\(V_2\\). The discrete Laplace equation from last time,</p> \\[ V_i = (V_{i-1}+V_{i+1})/2, \\] <p>gives two equations for these unknowns. Explicitly, these are</p> \\[ V_1 = (V_{0}+V_{2})/2 \\qquad \\text{and} \\qquad V_2 = (V_{1}+V_{3})/2. \\] <p>Putting all the unknowns, \\(V_1\\) and \\(V_2\\), on the left side of these equations and the knowns on the right we arrive at the system of equations:</p> \\[ \\begin{aligned} 2V_1-V_2 &amp;= V_0\\\\ -V_1+2V_2 &amp;= V_3. \\end{aligned} \\] <p>Which, in turn can be written as a matrix equation</p> \\[ \\begin{pmatrix} 2 &amp; -1\\\\ -1 &amp; 2 \\end{pmatrix}  \\begin{pmatrix} V_1\\\\ V_2 \\end{pmatrix} = \\begin{pmatrix} V_0\\\\ V_3 \\end{pmatrix}. \\] <p>This equation can be solved by multiplying both sides of the equation by the inverse of the matrix. For a 2X2 matrix</p> \\[ M=\\begin{pmatrix} a &amp; b\\\\ c &amp; d \\end{pmatrix}, \\] <p>the inverse matrix is </p> \\[ M^{-1} = \\frac{1}{\\det M} \\begin{pmatrix} d &amp; -b\\\\ -c &amp; a \\end{pmatrix}. \\] <p>For the present problem this yields $$ \\begin{pmatrix} V_1\\ V_2 \\end{pmatrix} =\\frac{1}{3} \\begin{pmatrix} 2 &amp; 1\\ 1 &amp; 2 \\end{pmatrix}  \\begin{pmatrix} V_0\\ V_3 \\end{pmatrix}, $$ or more explicitly  $$ V_1 = \\frac{2}{3}V_{0}+\\frac{1}{3}V_{3} \\qquad \\text{and} \\qquad V_2 = \\frac{1}{3}V_{0}+\\frac{2}{3} V_{3}. $$ We've solved the discrete Laplace equation on the 4-point lattice by hand. The key to this being a simple calculation, with no need for numerics, was that we had an easy to use formula for the inverse of the 2X2 matrix. </p>"},{"location":"ElecMag/RelaxationWithLinearAlgebra/#numpys-linear-algebra-package","title":"NumPy's Linear Algebra Package","text":"<p>For lattices with 5 and more points, the necessary matrix manipulations are more complicated. For this reason we will use NumPy's linear algebra package. Below are illustrations for loading the package, defining a 3X3 matrix, taking the determinant and inverse of that matrix, and multiplying a vector by it:</p> <pre><code>import numpy.linalg as linalg\n</code></pre> <pre><code>M = np.zeros([3,3])\n\n# Set the neighbors to the diagonal to 1\nM[0,1]=1\nM[1,0]=1\nM[1,2]=1\nM[2,1]=1\n\n# Set the diagonals to -4\nfor i in range(3): \n    M[i, i] = -4\n\nprint(M)\n</code></pre> <pre><code>[[-4.  1.  0.]\n [ 1. -4.  1.]\n [ 0.  1. -4.]]\n</code></pre> <pre><code>linalg.det(M)\n</code></pre> <pre><code>-56.00000000000002\n</code></pre> <pre><code>Minv=linalg.inv(M)\nprint(Minv)\n\nprint(np.matmul(M,Minv)) #or, more briefly:\nM@Minv\n</code></pre> <pre><code>[[-0.26785714 -0.07142857 -0.01785714]\n [-0.07142857 -0.28571429 -0.07142857]\n [-0.01785714 -0.07142857 -0.26785714]]\n[[ 1.0000000e+00  0.0000000e+00  0.0000000e+00]\n [-6.9388939e-18  1.0000000e+00  0.0000000e+00]\n [ 0.0000000e+00  0.0000000e+00  1.0000000e+00]]\n\n\n\n\n\narray([[ 1.0000000e+00,  0.0000000e+00,  0.0000000e+00],\n       [-6.9388939e-18,  1.0000000e+00,  0.0000000e+00],\n       [ 0.0000000e+00,  0.0000000e+00,  1.0000000e+00]])\n</code></pre> <pre><code># define a vector\nv=np.array([1,-1,4])\n\nprint(np.matmul(M,v)) #or\nM@v\n</code></pre> <pre><code>[ -5.   9. -17.]\n\n\n\n\n\narray([ -5.,   9., -17.])\n</code></pre> <p> Exercise (a): Take the 5-point lattice [-2,-1,0,1,2] as an example. Fix the boundary values to \\(V_{-2}=3\\) and \\(V_{2}=-1\\) and use linear algebra to solve the relaxation problem. Procceed by hand up until you have setup the matrix problem, but use Python code to invert the matrix and solve the linear system of equations.  </p> <p> Exercise (b): Write a function called RelaxLinAlg1D that implements this strategy for an arbitrary number of lattices points \\(N\\).</p>"},{"location":"ElecMag/RelaxationWithLinearAlgebra/#timing-code","title":"Timing Code","text":"<p>Python allows you to time how long your code takes to run. When you write code that has to repeat a calculation many times, for example by running it on a lattice with a large number of points N, it is important that your code does these calculations as efficiently as possible. This snippet allows you to test a code block's duration:</p> <pre><code>import time\n\nt0 = time.time()\ncode_block\nt1 = time.time()\n\ntotal = t1-t0\n</code></pre> <p>Exercise (c): Between the previous notebook and this one you have written two functions both of which implement the method of relaxation. Which of them is more efficient? You should investigate this question not just for one lattice size, but also check what happens as the lattice gets bigger and bigger. </p> <p>Warning: The method of Exercise (c) is important to know about. However, you should take the answer that you find with a grain of salt. Many human hours have been put into optimizing the linalg package, while we spent little time optimizing the iterative scheme. In fact, the two different approaches have different regimes where they are most useful; a deeper investigation of their respective strengths would be an excellent research project.</p>"}]}